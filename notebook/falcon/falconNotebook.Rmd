---
    title: "Falcon Notebook"
    author: "Gene Urrutia"  
    date: "`r format(Sys.Date())`"
    output:  
      html_document:  
        keep_md: true 
---  

# This is a demo dataset from relapse genome of neuroblastoma with matched normal
# from Eleveld et al. (Nature Genetics 2015).

# Falcon takes as input germline heterozygous variants, which can be called by 
# GATK or VarScan2.  See [Profiling germline heterozygous loci](https://github.com/yuchaojiang/MARATHON/blob/master/script/germline_het_loci.sh) for details.

#Load Falcon package
```{r}
library(falcon)
requireNamespace("falcon")
library(repmis)  
library(RCurl)
```
#source additional falcon functions
```{r}
faclonURL = "https://github.com/yuchaojiang/Canopy/blob/master/instruction"
source(paste0(faclonURL, "/falcon.qc.R?raw=True"))
source(paste0(faclonURL, "/falcon.output.R?raw=True"))
```

# download the primary and relapse germline heterozygous variants data (This data was generated using "germline_het_loci.sh" script)
```{r}
gitUrl = "https://github.com/yuchaojiang/MARATHON/blob/master/data"
source_data(paste0(gitUrl, "/relapse.rda?raw=True"))
coverageData = relapse
```

# calculate depth ratio (total read counts of tumor versus normal)
```{r}
rdep=sum(coverageData$Tumor_ReadCount_Total)/sum(coverageData$Normal_ReadCount_Total)
```


# Restrict our analysis to chromosome 14, where a copy-neutral loss of heterozygosity 
# has been previously reported.
```{r}
chr = 14
coverageChr=coverageData[which(coverageData[,'Chromosome']==chr),]
```
 
 
# remove variants with missing genotype
```{r}
nonMissing1 = coverageChr[,'Match_Norm_Seq_Allele1']!=' '
nonMissing2 = coverageChr[,'Match_Norm_Seq_Allele2']!=' '
nonMissing3 = coverageChr[,'Reference_Allele']!=' '
nonMissing4 = coverageChr[,'TumorSeq_Allele1']!=' '
nonMissing5 = coverageChr[,'TumorSeq_Allele2']!=' '
coverageChr=coverageChr[nonMissing1 & nonMissing2 & nonMissing3 & nonMissing4 & nonMissing5,]
```
  
# get germline heterozygous loci (normal allele1 != normal allele2)
```{r}
coverageChrHet=coverageChr[(as.matrix(coverageChr[,'Match_Norm_Seq_Allele1'])!=as.matrix(coverageChr[,'Match_Norm_Seq_Allele2'])),]
```
  

# QC procedures to remove false neg and false pos variants.
# The thresholds can be adjusted.

# remove indels (this can be relaxed but we think indels are harder to call than SNPs)
```{r}
indelThresh = 1
indel.filter1=nchar(as.matrix(coverageChrHet[,'Reference_Allele']))<=indelThresh
indel.filter2=nchar(as.matrix(coverageChrHet[,'Match_Norm_Seq_Allele1']))<=indelThresh
indel.filter3=nchar(as.matrix(coverageChrHet[,'Match_Norm_Seq_Allele2']))<=indelThresh
indel.filter4=nchar(as.matrix(coverageChrHet[,'TumorSeq_Allele1']))<=indelThresh
indel.filter5=nchar(as.matrix(coverageChrHet[,'TumorSeq_Allele2']))<=indelThresh
coverageChrHet=coverageChrHet[indel.filter1 & indel.filter2 & indel.filter3 & indel.filter4 & indel.filter5,]
```

# Filter on coverage: total number of reads greater than 30 in both tumor and normal

```{r}
coverageThresh = 30
depth.filter1=(coverageChrHet[,"Normal_ReadCount_Ref"]+coverageChrHet[,"Normal_ReadCount_Alt"])>=coverageThresh
depth.filter2=(coverageChrHet[,"Tumor_ReadCount_Ref"]+coverageChrHet[,"Tumor_ReadCount_Alt"])>=coverageThresh
coverageChrHet=coverageChrHet[depth.filter1 & depth.filter2,]
```  
  
  
  #########################
  # Generate FALCON input.
  #########################
  
# Data frame with four columns: tumor ref, tumor alt, normal ref, normal alt.
```{r}
readMatrix=as.data.frame(coverageChrHet[,c('Tumor_ReadCount_Ref',
                                                   'Tumor_ReadCount_Alt',
                                                   'Normal_ReadCount_Ref',
                                                   'Normal_ReadCount_Alt')])
colnames(readMatrix)=c('AT','BT','AN','BN')
dim(readMatrix); dim(coverageChrHet)
``` 
  

# Run FALCON and view results

```{r message=FALSE}
tauhat = getChangepoints(readMatrix)
cn = getASCN(readMatrix, tauhat=tauhat, rdep = rdep, threshold = 0.3)
```

# Chromosomal view of segmentation results. (save image file.)
```{r}
  #pdf(file=paste('falcon.relapse.',chr,'.pdf',sep=''),width=5,height=8)
  view(cn, pos=coverageChrHet[,'Start_position'], rdep = rdep)
  #dev.off()
 #save.image(file=paste('falcon_relapse_',chr,'.rda',sep=''))
```


# Further curate FALCON's segmentation.
  
  
# From the figure above, we see that:
# (1) There are small segments that need to be removed;
# (2) Consecutive segments with similar allelic copy number states need to be combined.
  
```{r}
if(length(tauhat)>0){
  length.thres=10^6  # Threshold for length of segments, in base pair.
  delta.cn.thres=0.3  # Threshold of absolute copy number difference between consecutive segments.
  falcon.qc.list = falcon.qc(readMatrix = readMatrix,
                             tauhat = tauhat,
                             cn = cn,
                             st_bp = coverageChrHet[,"Start_position"],
                             end_bp = coverageChrHet[,"End_position"],
                             rdep = rdep,
                             length.thres = length.thres,
                             delta.cn.thres = delta.cn.thres)
  tauhat=falcon.qc.list$tauhat
  cn=falcon.qc.list$cn
}
```


# Chromosomal view of QC'ed segmentation results.
```{r}
#pdf(file=paste('falcon.relapse.qc.',chr,'.pdf',sep=''),width=5,height=8)
view(cn,pos=coverageChrHet[,'Start_position'], rdep = rdep)
#  dev.off()
```
  

# Generate Canopy's input with s.d. measurement.

# This is to generate table output including genomic locations for 
# segment boudaries.
# For Canopy's input, we use Bootstrap-based method to estimate the
# standard deviations for the allele-specific copy numbers.

```{r}  
  falcon.output=falcon.output(readMatrix = readMatrix,
                              tauhat = tauhat,
                              cn = cn,
                              st_bp = coverageChrHet[,"Start_position"],
                              end_bp = coverageChrHet[,"End_position"],
                              nboot = 5000)
  falcon.output = cbind(chr=rep(chr,nrow(falcon.output)), falcon.output)
  falcon.output
  #write.table(falcon.output, file=paste('faclon.relapse.output.',chr,'.txt',sep=''), col.names =T, row.names = F, sep='\t', quote = F)
```  

